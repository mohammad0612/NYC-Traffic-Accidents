# -*- coding: utf-8 -*-
"""ORIE 3120 PM2 data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14cVWft-EUZ5wAAar2O5dxsqsbu1cFYs0
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures

# Load and preprocess the data
df = pd.read_csv('NYCAccidents2020.csv')
df = df[['BOROUGH', 'CRASH DATE', 'NUMBER OF PERSONS INJURED', 'NUMBER OF PERSONS KILLED']]
df = df.dropna()
df['Crash Date'] = pd.to_datetime(df['CRASH DATE'])
df = df[(df['Crash Date'].dt.month.isin([1, 2, 3, 6, 7, 8])) & (df['Crash Date'].dt.year.isin([2014, 2020]))]
df['YEAR'] = df['Crash Date'].dt.year
df['MONTH'] = df['Crash Date'].dt.month

# Perform one-hot encoding on the 'BOROUGH' column
df = pd.concat([df, pd.get_dummies(df['BOROUGH'], prefix='BOROUGH')], axis=1)

# Split the data into training and test sets
train = df[df['YEAR'] == 2020]
test = df[df['YEAR'] == 2020]

# Fit a polynomial regression model
poly = PolynomialFeatures(degree=3)
X_train = poly.fit_transform(train[['BOROUGH_BRONX', 'BOROUGH_BROOKLYN', 'BOROUGH_MANHATTAN', 'BOROUGH_QUEENS', 'BOROUGH_STATEN ISLAND', 'MONTH']])
X_test = poly.fit_transform(test[['BOROUGH_BRONX', 'BOROUGH_BROOKLYN', 'BOROUGH_MANHATTAN', 'BOROUGH_QUEENS', 'BOROUGH_STATEN ISLAND', 'MONTH']])
y_train = train['NUMBER OF PERSONS INJURED']
y_test = test['NUMBER OF PERSONS INJURED']

model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions and plot the results
X_pred = poly.fit_transform(df[['BOROUGH_BRONX', 'BOROUGH_BROOKLYN', 'BOROUGH_MANHATTAN', 'BOROUGH_QUEENS', 'BOROUGH_STATEN ISLAND', 'MONTH']])
y_pred = model.predict(X_pred)

plt.scatter(df['YEAR'], y_pred)
plt.xlabel('Year')
plt.ylabel('Predicted Number of Accidents')
plt.title('Predicted Number of Accidents by Year')
plt.xlim(2020, 2025)
plt.show()

df = pd.read_csv('nypd-motor-vehicle-collisions.csv')
df.head()

new3 = df[['ACCIDENT DATE', 'ACCIDENT TIME']]
new3.insert(2, "month", new3['ACCIDENT DATE'].astype("datetime64").dt.month, True)
new3.dropna()
new4 = new3.groupby('month').count()
x = ['Jan', 'Feb', 'Mar', 'Apr', 'May' , 'Jun','Jul' ,'Aug','Sep', 'Oct','Nov', 'Dec']
plt.bar(x, new4['ACCIDENT DATE'])
plt.title('Total Number of NYC Crashes By Month From 2013 - 2019')
plt.xlabel('Month of the year')
plt.ylabel('Number of vehicle accidents')

import random
import matplotlib.colors as mcolors

new2 = df.groupby(['BOROUGH']).count()
my_explode = (0.02, 0.02, 0.02, 0.02,0.02)
colors = ['cornflowerblue', 'palegreen', 'khaki', 'lightcoral', 'mistyrose']
labels = 'BRONX', 'BROOKYLN', 'MANHATTAN', 'QUEENS', 'STATEN ISLAND'
plt.pie(new2['ACCIDENT TIME'], labels = labels, startangle = 15, autopct = '%1.1f%%', shadow = False, explode = my_explode, colors = colors)
plt.title('Percentage of NYC Crashes per Borough from 2013 - 2019')
plt.axis('equal')

df = pd.read_csv('nypd-motor-vehicle-collisions.csv')
new = df[['ACCIDENT TIME','BOROUGH']]
new = new.dropna()
new.insert(2, "hour", new['ACCIDENT TIME'].astype("datetime64").dt.hour, True)

newcount = new.groupby('hour').count()

plt.plot(newcount['BOROUGH'])
plt.xlabel('Hour of the day')
plt.ylabel('Number of crashes')
plt.title('Number of NYC Vehicle Accidents vs. Hour of the Day')
plt.xticks(np.arange(0,24,2))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load the data
#df = pd.read_csv('nypd-motor-vehicle-collisions.csv')
new = df[['ACCIDENT TIME','BOROUGH']]
new = new.dropna()
new.insert(2, "hour", new['ACCIDENT TIME'].astype("datetime64").dt.hour, True)

# Compute the counts
newcount = new.groupby('hour').count()

# Plot the line graph
plt.plot(newcount['BOROUGH'].iloc[0:13], color='orange')
plt.plot(newcount['BOROUGH'].iloc[12:], color = 'blue')
plt.xlabel('Hour of the day')
plt.ylabel('Number of crashes')
plt.title('Number of NYC Vehicle Accidents vs. Hour of the Day')

# Add a shaded region for hours 12-23
#plt.axvspan(12, 23, alpha=0.5, color='red')

# Set the x-axis tick labels
plt.xticks(np.arange(0, 24, 2))

# Show the plot
import matplotlib.patches as mpatches
#import matplotlib.pyplot as plt

orange_patch = mpatches.Patch(color='orange', label='AM')
blue_patch = mpatches.Patch(color='blue', label='PM')
plt.legend(handles=[orange_patch, blue_patch])

plt.show()

newcount['BOROUGH']

#df = pd.read_csv('nypd-motor-vehicle-collisions.csv')
new3 = df[['ACCIDENT DATE']]
new3.insert(1, "year", new3['ACCIDENT DATE'].astype("datetime64").dt.year, True)
new3.dropna()
new4 = new3.groupby('year').count()
x = ['2012','2013','2014','2015','2016','2017','2018','2019']
plt.plot(x, new4['ACCIDENT DATE'])
plt.title('Total Number of NYC Crashes From 2013 - 2019')
plt.xlabel('Year')
plt.ylabel('Number of vehicle accidents')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm

# Load the data
#df = pd.read_csv("nyc-vehicle-collisions.csv", low_memory=False)

# Filter the data for the years 2013-2019
df = df[df['ACCIDENT DATE'].str.contains('2013|2014|2015|2016|2017|2018|2019')]

# Convert the DATE column to a datetime format
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])

# Create a new column for the year
df['YEAR'] = df['DATE'].dt.year

# Create a new column for the month
df['MONTH'] = df['DATE'].dt.month

# Group the data by year and borough and count the number of accidents
df_accidents = df.groupby(['YEAR', 'BOROUGH'])['DATE'].count().reset_index()
df_accidents = df_accidents.rename(columns={'DATE': 'ACCIDENTS'})

# Group the data by year and borough and sum the number of deaths
df_deaths = df.groupby(['YEAR', 'BOROUGH'])['NUMBER OF PERSONS KILLED'].sum().reset_index()
df_deaths = df_deaths.rename(columns={'NUMBER OF PERSONS KILLED': 'DEATHS'})

# Pivot the data to have years as rows and boroughs as columns
df_accidents_pivot = df_accidents.pivot(index='YEAR', columns='BOROUGH', values='ACCIDENTS')
df_deaths_pivot = df_deaths.pivot(index='YEAR', columns='BOROUGH', values='DEATHS')

# Drop the NaN values
df_accidents_pivot = df_accidents_pivot.dropna()
df_deaths_pivot = df_deaths_pivot.dropna()

# Create the X and y arrays for the accidents model
X_accidents = df_accidents_pivot.index.values.reshape(-1, 1)
y_accidents = df_accidents_pivot.values

# Create the X and y arrays for the deaths model
X_deaths = df_deaths_pivot.index.values.reshape(-1, 1)
y_deaths = df_deaths_pivot.values

# Fit the accidents model
regressor_accidents = sm.OLS(y_accidents, sm.add_constant(X_accidents))
results_accidents = regressor_accidents.fit()

# Fit the deaths model
regressor_deaths = sm.OLS(y_deaths, sm.add_constant(X_deaths))
results_deaths = regressor_deaths.fit()

# Predict the number of accidents and deaths for the years 2020-2030
X_pred = np.arange(2020, 2031).reshape(-1, 1)

y_pred_accidents = results_accidents.predict(sm.add_constant(X_pred))
y_pred_deaths = results_deaths.predict(sm.add_constant(X_pred))

# Plot the predicted number of accidents
plt.plot(X_pred, y_pred_accidents, label='Predicted')
plt.scatter(df_accidents_pivot.index, df_accidents_pivot['BRONX'], label='Actual')
plt.title('Predicted Number of Accidents in NYC')
plt.xlabel('Year')
plt.ylabel('Number of Accidents')
plt.legend()
plt.xlim(2020,2030)
plt.show()

# Plot the predicted number of deaths
plt.plot(X_pred, y_pred_deaths, label='Predicted')
plt.scatter(df_deaths_pivot.index, df_deaths_pivot['BRONX'], label = 'Actual' )
plt.title('Predicted Number of Deaths in NYC')
plt.xlabel('Year')
plt.ylabel('Number of Deaths')
plt.legend()
plt.xlim(2020,2030)
plt.show()

import pandas as pd
import statsmodels.api as sm

# Load the dataset
df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

# Filter the data for the years 2013-2019
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])
df = df[(df['DATE'].dt.year >= 2013) & (df['DATE'].dt.year <= 2019)]
df['YEAR'] = df['DATE'].dt.year
# Create separate dataframes for each borough
bronx_df = df[df['BOROUGH'] == 'BRONX']
brooklyn_df = df[df['BOROUGH'] == 'BROOKLYN']
manhattan_df = df[df['BOROUGH'] == 'MANHATTAN']
queens_df = df[df['BOROUGH'] == 'QUEENS']
staten_df = df[df['BOROUGH'] == 'STATEN ISLAND']

# Create a function to train and make predictions using linear regression
def predict_accidents(df):
    # Group the data by year and borough and count the number of accidents
    accidents_by_year_borough = df.groupby(['YEAR', 'BOROUGH']).size().reset_index(name='ACCIDENTS')

    # Convert the year column to numeric values
    accidents_by_year_borough['YEAR'] = pd.to_numeric(accidents_by_year_borough['YEAR'])

    # Create separate arrays for the predictor variable (year) and the target variable (number of accidents)
    X = accidents_by_year_borough['YEAR']
    y = accidents_by_year_borough['ACCIDENTS']

    # Add a constant to the predictor variable
    X = sm.add_constant(X)

    # Train the linear regression model
    model = sm.OLS(y, X).fit()

    # Make predictions for the years 2020-2030
    future_years = pd.Series(range(2020, 2031))
    future_years = sm.add_constant(future_years)
    y_pred = model.predict(future_years)

    # Plot the predicted values
    model_name = df['BOROUGH'].iloc[0]
    plt.plot(range(2013, 2020), y, label=f'Actual {model_name}')
    plt.plot(range(2020, 2031), y_pred, label=f'Predicted {model_name}')
    plt.xlabel('Year')
    plt.ylabel('Number of accidents')
    plt.title(f'Number of accidents in {model_name}')
    plt.legend()
    plt.xlim(2020,2030)
    plt.show()

# Make predictions for each borough
predict_accidents(bronx_df)
predict_accidents(brooklyn_df)
predict_accidents(manhattan_df)
predict_accidents(queens_df)
predict_accidents(staten_df)

import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt

# Load the dataset
#df = pd.read_csv('nyc-vehicle-collisions.csv')

# Filter the data for the years 2013-2019
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])
df = df[(df['DATE'].dt.year >= 2013) & (df['DATE'].dt.year <= 2019)]

# Group the data by year and count the number of accidents
total_accidents_by_year = df.groupby(df['DATE'].dt.year)['DATE'].count().reset_index(name='ACCIDENTS')

# Convert the year column to numeric values
total_accidents_by_year['DATE'] = pd.to_numeric(total_accidents_by_year['DATE'])

# Create separate arrays for the predictor variable (year) and the target variable (number of accidents)
X = total_accidents_by_year['DATE']
y = total_accidents_by_year['ACCIDENTS']

# Add a constant to the predictor variable
X = sm.add_constant(X)

# Train the linear regression model
model = sm.OLS(y, X).fit()

# Make predictions for the years 2020-2030
future_years = pd.Series(range(2020, 2031))
future_years = sm.add_constant(future_years)
y_pred = model.predict(future_years)

# Plot the actual values and predicted values
plt.plot(total_accidents_by_year['DATE'], total_accidents_by_year['ACCIDENTS'], label='Actual')
plt.plot(future_years, y_pred, '.-', label='Predicted')
plt.xlabel('Year')
plt.ylabel('Number of Accidents')
plt.title('Predicting Total Number of Accidents in NYC For 2020 to 2030')
#plt.legend()
plt.xlim(2020,2030)
plt.ylim(216500, 225000)
plt.xticks(np.arange(2020, 2031,1))
plt.show()

import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

# Filter the data for the years 2013-2019
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])
df = df[(df['DATE'].dt.year >= 2013) & (df['DATE'].dt.year <= 2019)]

# Group the data by year and count the number of accidents
total_accidents_by_year = df.groupby(df['DATE'].dt.year)['DATE'].count().reset_index(name='NUMBER OF PERSONS INJURED')

# Convert the year column to numeric values
total_accidents_by_year['DATE'] = pd.to_numeric(total_accidents_by_year['DATE'])

# Create separate arrays for the predictor variable (year) and the target variable (number of accidents)
X = total_accidents_by_year['DATE']
y = total_accidents_by_year['NUMBER OF PERSONS INJURED']

# Add a constant to the predictor variable
X = sm.add_constant(X)

# Train the linear regression model
model = sm.OLS(y, X).fit()

# Make predictions for the years 2020-2030
future_years = pd.Series(range(2020, 2031))
future_years = sm.add_constant(future_years)
y_pred = model.predict(future_years)

# Plot the actual values and predicted values
plt.plot(total_accidents_by_year['DATE'], total_accidents_by_year['NUMBER OF PERSONS INJURED'], label='Actual')
plt.plot(future_years, y_pred, '.-', label='Predicted')
plt.xlabel('Year')
plt.ylabel('Number of Deaths')
plt.title('Predicting Total Number of Deaths in NYC For 2020 to 2030')
#plt.legend()
plt.xlim(2020,2030)
plt.xticks(np.arange(2020, 2031,1))
plt.show()

model.summary()

plt.plot(X, model.resid, '.', markersize = 0.5)

import seaborn as sns
sns.regplot(X, model.resid, lowess=True, line_kws = {'color': 'black'}, scatter_kws = {'s' : 0.5})

import seaborn as sns
n = 10000
x = np.random.rand(n) # uniform
eps = np.random.randn(n) # eps are independent normal (0 ,1)
y = 1 + 4* x**1.4  + eps
model = sm . OLS (y , sm . add_constant ( x )). fit ()
sns.regplot(x = x , y=  model.resid , lowess=True, line_kws = {'color': 'black'}, scatter_kws = {'s' : 0.5})
plt.xlabel('Number of Accidents Forecasted')
plt.ylabel('Residuals')
plt.title('Residuals of Forecasted Accidents')

import pandas as pd
import statsmodels.api as sm

# Load the dataset
#df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

# Filter the data for the years 2013-2019
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])
df = df[(df['DATE'].dt.year >= 2013) & (df['DATE'].dt.year <= 2019)]

# Create separate dataframes for each borough
bronx_df = df[df['BOROUGH'] == 'BRONX']
brooklyn_df = df[df['BOROUGH'] == 'BROOKLYN']
manhattan_df = df[df['BOROUGH'] == 'MANHATTAN']
queens_df = df[df['BOROUGH'] == 'QUEENS']
staten_df = df[df['BOROUGH'] == 'STATEN ISLAND']

# Create a function to train and make predictions using linear regression
def predict_accidents(df):
    df = df.dropna()
    # Group the data by year and borough and count the number of accidents and add latitude and longitude columns
    accidents_by_year_borough = df.groupby(['YEAR', 'BOROUGH', 'NUMBER OF PERSONS INJURED']).agg({'LATITUDE': 'mean', 'LONGITUDE': 'mean'}).reset_index()
    accidents_by_year_borough.rename(columns={'UNIQUE KEY': 'ACCIDENTS'}, inplace=True)

    # Convert the year column to numeric values
    accidents_by_year_borough['YEAR'] = pd.to_numeric(accidents_by_year_borough['YEAR'])

    # Create separate arrays for the predictor variables (year, latitude, and longitude) and the target variable (number of accidents)
    X = accidents_by_year_borough[['YEAR', 'LATITUDE', 'LONGITUDE']]
    y = accidents_by_year_borough['NUMBER OF PERSONS INJURED' ]

    # Add a constant to the predictor variables
    X = sm.add_constant(X)

    # Train the linear regression model
    model = sm.OLS(y, X).fit()

    # Make predictions for the years 2020-2030
    future_years = pd.DataFrame({'YEAR': range(2020, 2031), 'LATITUDE': X['LATITUDE'].mean(), 'LONGITUDE': X['LONGITUDE'].mean()})
    future_years = sm.add_constant(future_years)
    y_pred = model.predict(future_years)

    # Plot the predicted values
    model_name = df['BOROUGH'].iloc[0]
    plt.plot(range(2013, 2020), y, label=f'Actual {model_name}')
    plt.plot(range(2020, 2031), y_pred, label=f'Predicted {model_name}')
    plt.xlabel('Year')
    plt.ylabel('Number of accidents')
    plt.title(f'Number of accidents in {model_name}')
    plt.legend()
    plt.xlim(2020,2030)
    plt.show()

# Make predictions for each borough
predict_accidents(bronx_df)
predict_accidents(brooklyn_df)
predict_accidents(manhattan_df)
predict_accidents(queens_df)
predict_accidents(staten_df)

import pandas as pd
import matplotlib.pyplot as plt

# load the dataset into a pandas DataFrame
df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

# convert the DATE column to a datetime object and extract the day of the week
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])
df['DAY_OF_WEEK'] = df['DATE'].dt.day_name()

# group the DataFrame by the day of the week and count the number of occurrences
accidents_by_day = df.groupby('DAY_OF_WEEK')['DATE'].count()

# create a bar plot
accidents_by_day.plot(kind='bar', rot=0)
plt.xlabel('Day of the Week')
plt.ylabel('Number of Accidents')
plt.title('Total Number of Accidents by Day of the Week')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt


# Convert the 'DATE' column to datetime format
df['DATE'] = pd.to_datetime(df['ACCIDENT DATE'])

# Create a new column for the day of the week
df['DAY_OF_WEEK'] = df['DATE'].dt.day_name()

# Group the data by day of the week and count the number of accidents
accidents_by_day = df.groupby('DAY_OF_WEEK')['DATE'].count()

# Define the order of the days of the week
day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']

# Reindex the DataFrame to put the days of the week in the desired order
accidents_by_day = accidents_by_day.reindex(day_order)

# Plot the data
plt.bar(accidents_by_day.index, accidents_by_day.values)
plt.xticks(rotation=45, ha='right')
plt.xlabel('Day of the Week')
plt.ylabel('Number of Accidents')
plt.title("Total Number of Accidents By Day of the Week")
plt.show()

new3 = df[['ACCIDENT DATE', 'NUMBER OF PERSONS INJURED']]
new3.insert(2, "month", new3['ACCIDENT DATE'].astype("datetime64").dt.month, True)
new3.dropna()
new3 = new3[['month', 'NUMBER OF PERSONS INJURED']]
new4 = new3.groupby('month')['NUMBER OF PERSONS INJURED'].count()
x = ['Jan', 'Feb', 'Mar', 'Apr', 'May' , 'Jun','Jul' ,'Aug','Sep', 'Oct','Nov', 'Dec']
plt.bar(x, new4)
plt.title('Total Number of Persons Injured By Month From 2013 - 2019')
plt.xlabel('Month of the year')
plt.ylabel('Number of vehicle accidents')

import pandas as pd
import matplotlib.pyplot as plt

# Read the CSV file into a Pandas DataFrame
#df = pd.read_csv("nyc-vehicle-collisions.csv")

# Group the data by zip code and count the number of accidents per zip code
accidents_by_zipcode = df.groupby("ZIP CODE")["ACCIDENT DATE"].count()
accidents_by_zipcode = df.groupby('ZIP CODE').size().nlargest(10)

# Plot the number of accidents per zip code using a bar plot
accidents_by_zipcode.plot(kind="bar", figsize=(10,6))

# Set the plot title and axis labels
accidents_by_zipcode.plot(kind='bar', figsize=(10, 6))
plt.xticks(rotation=0, ha='right')
plt.title('Top 10 Zip Codes with Highest Number of Accidents')
plt.xlabel('Zip Code')
plt.ylabel('Number of Accidents')
plt.show()

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# read in the dataset
#df = pd.read_csv('nyc-vehicle-collisions.csv')

# convert zip code column to integer type
#df = df['ZIP CODE'].dropna()
#df['ZIP CODE'] = df['ZIP CODE'].astype(int)

# get top 10 zip codes by accident count
top_zipcodes = df['ZIP CODE'].value_counts().nlargest(10).index.tolist()

# create dictionary to map boroughs to colors
colors = {
    'QUEENS': 'blue',
    'BROOKLYN': 'green',
    'MANHATTAN': 'red',
    'BRONX': 'orange',
    'STATEN ISLAND': 'purple'
}

# filter dataframe to only include top 10 zip codes
df_top_zipcodes = df[df['ZIP CODE'].isin(top_zipcodes)]

# map boroughs to colors for each zip code
colors_by_zipcode = df_top_zipcodes.set_index('ZIP CODE')['BOROUGH'].map(colors)

# plot bar graph of accidents by zip code
df_top_zipcodes.groupby('ZIP CODE')['BOROUGH'].count().sort_values().plot(kind='barh', color=colors_by_zipcode)

# set axis labels and title
plt.xlabel('Number of Accidents')
green_patch = mpatches.Patch(color='green', label='Brookyln')
blue_patch = mpatches.Patch(color='blue', label='Queens')
plt.legend(handles=[green_patch, blue_patch])
plt.ylabel('Zip Code')
plt.title('Top 10 Zip Codes by Number of Accidents')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
import os
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import pandas as pd
import seaborn as sns
# import plotly
!pip install chart-studio
from chart_studio import plotly
import plotly.graph_objs as go
from plotly.offline import init_notebook_mode, iplot
init_notebook_mode()

# %matplotlib inline
# Any results you write to the current directory are saved as output.

### Function to plot
def plot_borough_data(df_input, str_title):
    """
    Takes a dataframe plots it on a plotly chart.

    Parameters
    ----------
    df_input: pandas.DataFrame
        A pandas dataframe with dates and numerical data
    str_title: str
        Title for the plot

    Returns
    ----------
    plotly.plot

    """
    list_data = []

    ### loop through and create our list of data
    for c in df_input.columns:
        list_data.append(go.Scatter(x=df_data.index,
                                    y=df_data[c],
                                    name=c.title()))

    ### specify the layout of our figure
    layout = dict(title = str_title,
                  xaxis= dict(title= 'Date',
                              ticklen= 5,
                              zeroline= False))

    ### create and show our figure
    fig = dict(data = list_data, layout = layout)
    return(iplot(fig))

### list of columns to read in
list_cols = ["DATE",
             "BOROUGH",
             "NUMBER OF PERSONS INJURED",
             "NUMBER OF PERSONS KILLED"]

### read in the collision dataset
df_colls = df

### Convert date to a datetime before we start
df_colls["DATE"] = pd.to_datetime(df_colls["ACCIDENT DATE"])

### Total injuries by month by borough
df_data = pd.pivot_table(data=df_colls,
                         values="NUMBER OF PERSONS INJURED",
                         index=df_colls["DATE"].dt.strftime("%Y-%m"),
                         columns="BOROUGH",
                         aggfunc=np.sum
                        )

plot_borough_data(df_data, "Vehicular Injuries by Borough")
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# load the dataset
#df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

# create a new column for month
df['MONTH'] = pd.to_datetime(df['ACCIDENT DATE']).dt.month

# group the dataframe by month and aggregate the total number of persons injured
injuries_by_month = df.groupby('MONTH')['NUMBER OF PERSONS INJURED'].sum()

# create a line plot of the total number of persons injured by month
x = ['Jan', 'Feb', 'Mar', 'Apr', 'May' , 'Jun','Jul' ,'Aug','Sep', 'Oct','Nov', 'Dec']
plt.plot(x, injuries_by_month.values)
plt.plot()
plt.xlabel('Month')
plt.ylabel('Total Number of Persons Injured')
plt.title('Total Number of Persons Injured by Month')


new3 = df[['ACCIDENT DATE', 'ACCIDENT TIME']]
new3.insert(2, "month", new3['ACCIDENT DATE'].astype("datetime64").dt.month, True)
new3.dropna()
new4 = new3.groupby('month').count()
x = ['Jan', 'Feb', 'Mar', 'Apr', 'May' , 'Jun','Jul' ,'Aug','Sep', 'Oct','Nov', 'Dec']
plt.plot(x, new4['ACCIDENT DATE'])
plt.title('Total Number of NYC Crashes By Month From 2013 - 2019')
plt.xlabel('Month of the year')
plt.ylabel('Number of vehicle accidents')

green_patch = mpatches.Patch(color='orange', label='Number of Accidents')
blue_patch = mpatches.Patch(color='blue', label='Number of Persons Injured')
plt.legend(handles=[green_patch, blue_patch])

plt.show()

df['CONTRIBUTING FACTOR VEHICLE 1']

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

new2 = df[['CONTRIBUTING FACTOR VEHICLE 1', 'ACCIDENT DATE']]
new2.insert(2, "DAY OF WEEK", new2['ACCIDENT DATE'].astype("datetime64").dt.day_name(), True)
new2 = new2.dropna()

new3 = new2[new2['CONTRIBUTING FACTOR VEHICLE 1'] == 'Unsafe Speed']
new3 = new3.groupby('DAY OF WEEK')['CONTRIBUTING FACTOR VEHICLE 1'].count()
new3

pred = df[['CONTRIBUTING FACTOR VEHICLE 1', 'ACCIDENT DATE', 'ACCIDENT TIME' ,'BOROUGH', 'NUMBER OF PERSONS KILLED', 'NUMBER OF PERSONS INJURED', 'VEHICLE TYPE CODE 1', 'COLLISION_ID']]

filter4 = (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Passing Too Closely') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Driver Inattention/Distraction') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Unsafe Speed') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Passing or Lange Usage Improper') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Failure to Yield Right-of-Way') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Unsafe Backing') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Passing Too Closely') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Traffic Control Disregarded') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Other Electronic Device') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Turning Improperly') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Unsafe Lane Changing') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Turning Improperly') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Traffic Control Disregarded') | (pred['CONTRIBUTING FACTOR VEHICLE 1'] == 'Driver Inexperience')

filter3 = (pred['VEHICLE TYPE CODE 1'] == 'Sedan') | (pred['VEHICLE TYPE CODE 1'] == 'Station Wagon/Sport Utility Vehicle') | (pred['VEHICLE TYPE CODE 1'] == 'SPORT UTILITY / STATION WAGON') | (pred['VEHICLE TYPE CODE 1'] == 'Taxi') | (pred['VEHICLE TYPE CODE 1'] == 'Pick-up Truck') | (pred['VEHICLE TYPE CODE 1'] == 'PASSENGER VEHICLE')

pred = pred[filter3]

pred = pred[filter4]

pred['BOROUGH'] = pred['BOROUGH'].replace({
    'BROOKLYN': 1,
    'BRONX': 2,
    'QUEENS': 3,
    'STATEN ISLAND': 4,
    'MANHATTAN': 5
})

pred['VEHICLE TYPE CODE 1'] = pred['VEHICLE TYPE CODE 1'].replace({
    'Sedan' : 1 ,
    'Station Wagon/Sport Utility Vehicle' : 2,
    'SPORT UTILITY / STATION WAGON' : 2,
    'Taxi' : 3,
    'Pick-up Truck' : 4,
    'PASSENGER VEHICLE' : 5

})

pred['CONTRIBUTING FACTOR VEHICLE 1'] = pred['CONTRIBUTING FACTOR VEHICLE 1'].replace({
  'Passing Too Closely' : 1,
  'Driver Inattention/Distraction' : 2,
  'Unsafe Speed' : 3,
  'Passing or Lange Usage Improper' : 4,
  'Failure to Yield Right-of-Way' : 5,
  'Unsafe Backing' : 6,
  'Passing Too Closely' : 7,
  'Traffic Control Disregarded' : 8 ,
  'Other Electronic Device' : 9,
  'Unsafe Lane Changing' : 10,
  'Turning Improperly' : 11,
  'Traffic Control Disregarded' : 12,
  'Driver Inexperience' : 13



})

pred['ACCIDENT DATE'] = pred['ACCIDENT DATE'].astype("datetime64")
#pred['ACCIDENT DATE'] = df['ACCIDENT DATE'].astype(int) // 10**9
pred['HOUR'] = pred['ACCIDENT TIME'].astype("datetime64").dt.hour
pred['DAY OF WEEK'] = pred['ACCIDENT DATE'].dt.day_of_week
pred = pred.dropna()

pred

pred = pred.apply(pd.to_numeric, errors='coerce').dropna()

pred['CONTRIBUTING FACTOR VEHICLE 1'].unique()

filter = (pred['HOUR'] > 2) & (pred['HOUR'] < 6)
filter2 = (pred['DAY OF WEEK'] == 3) | (pred['DAY OF WEEK'] == 4)
#filter3 = (pred['CONTRIBUTING FACTOR VEHICLE 1' > 0]) & (pred['CONTRIBUTING FACTOR VEHICLE 1'] < 10)
pred = pred[filter]
pred = pred[filter2]
pred

pred['CONTRIBUTING FACTOR VEHICLE 1'].unique()

pred2 = pred.groupby('CONTRIBUTING FACTOR VEHICLE 1').count()
pred2



import statsmodels.api as sm

X = pred[['CONTRIBUTING FACTOR VEHICLE 1', 'BOROUGH', 'NUMBER OF PERSONS KILLED', 'VEHICLE TYPE CODE 1', 'COLLISION_ID']]
Y = pred['NUMBER OF PERSONS INJURED']/100

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 100)

model = sm.Logit(Y_train, sm.add_constant(X_train)).fit()
model.summary()

from sklearn.model_selection import train_test_split

X = pred[['BOROUGH', 'NUMBER OF PERSONS KILLED', 'VEHICLE TYPE CODE 1', 'COLLISION_ID', 'NUMBER OF PERSONS INJURED' ,'HOUR', 'DAY OF WEEK']]
Y = pred['CONTRIBUTING FACTOR VEHICLE 1']
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 100)


#for i in range(9):
 # X = pred[['BOROUGH', 'NUMBER OF PERSONS KILLED', 'VEHICLE TYPE CODE 1', 'COLLISION_ID', 'NUMBER OF PERSONS INJURED' ,'HOUR', 'DAY OF WEEK']]
  #Y = pred['CONTRIBUTING FACTOR VEHICLE 1']

  #X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 100)

pred3 = pred.copy()
pred3['CONTRIBUTING FACTOR VEHICLE 1'] = pred['CONTRIBUTING FACTOR VEHICLE 1'].replace({1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11 : 0, 12: 0, 13:1})

pred3['CONTRIBUTING FACTOR VEHICLE 1'].unique()

prob = []
p1 = []
p2 = []
p3 = []
p4 = []
p5 = []

import statsmodels.api as sm

X = pred3[['BOROUGH', 'NUMBER OF PERSONS KILLED', 'VEHICLE TYPE CODE 1', 'COLLISION_ID', 'NUMBER OF PERSONS INJURED']]
Y = (pred3['CONTRIBUTING FACTOR VEHICLE 1'] ).astype(int)
from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 100)

model = sm.Logit(Y_train, sm.add_constant(X_train)).fit()
#model = sm.Logit(Y, sm.add_constant(X)).fit()
model.summary()
preds = model.predict(sm.add_constant(X_test))
prob.append(np.mean(preds))
p1.append(np.mean(model.pvalues[1]))
p2.append(np.mean(model.pvalues[2]))
p3.append(np.mean(model.pvalues[3]))
p4.append(np.mean(model.pvalues[4]))
p5.append(np.mean(model.pvalues[5]))

prob[1] = 0
p1[1] = 0
p2[1] = 0
p3[1] = 0
p4[1] = 0
p5[1] = 0

print(prob)
print(np.mean(p1))
print(np.mean(p2))
print(np.mean(p3))
print(np.mean(p4))
print(np.mean(p5))

sum = np.sum(prob)
prob2 = prob/sum
prob2

x = ['Driver Inattention', 'Unsafe Speed', 'Failure to Yield Right-of-Way', 'Electronic Device', 'Unsafe Lane Changing', 'Turning Improperly', 'Traffic Control Disregared' ,'Driver Inexperience']
y = [0.56498555, 0.07861949, 0.11330686, 0.00452351, 0.02180479, 0.06604989, 0.09816818, 0.05254173]
plt.bar(x,y)
plt.xticks(rotation=45, ha='right')
plt.ylabel('Probability of Factor')
plt.title('Probability of Contributing Factors For NYC Accidents During Rush Hours')

plt.plot (X , model.resid , '.', markersize =0.5)



preds3 = []

preds = model.predict(sm.add_constant(X_test))
print(np.mean(preds))
preds3.append(np.mean(preds))

preds3

Y

#!pip install folium
import folium
from folium.plugins import HeatMap

# Create a map centered at NYC
map = folium.Map(location=[40.7128, -74.0060], zoom_start=10)
df = df.dropna()

# Filter the dataframe to only include accidents with latitude and longitude data
df_filtered = df[(df.LATITUDE.notnull()) & (df.LONGITUDE.notnull())]

# Define the coordinates and accident counts as lists
coordinates = df_filtered[['LATITUDE', 'LONGITUDE']].values.tolist()
accident_counts = df_filtered['BOROUGH'].value_counts().tolist()

# Define the borough names
borough_names = ['BRONX', 'BROOKLYN', 'MANHATTAN', 'QUEENS', 'STATEN ISLAND']

# Define a dictionary to map the borough names to their respective indices
borough_dict = {borough_names[i]: i for i in range(len(borough_names))}

# Create a list of borough indices for each accident
borough_indices = [borough_dict[borough] for borough in df_filtered['BOROUGH']]

# Create a list of colors to represent each borough
colors = ['red', 'blue', 'green', 'purple', 'orange']

# Create a list of markers, one for each accident, with the corresponding color and tooltip
markers = [folium.Marker(location=coordinates[i], icon=folium.Icon(color=colors[borough_indices[i]]), tooltip=f'Borough: {df_filtered.iloc[i]["BOROUGH"]}') for i in range(len(df_filtered))]

# Add the markers to the map
#for marker in markers:
 #   marker.add_to(map)

# Create a HeatMap layer based on the accident coordinates and counts
heatmap_layer = HeatMap(data=coordinates, weights=accident_counts, radius=15)

# Add the HeatMap layer to the map
heatmap_layer.add_to(map)
#!pip install gmaps
import gmaps

#fig = gmaps.figure(center=(40.7, -74.0), zoom_level=10)
#heatmap_layer = gmaps.heatmap_layer(locations, weights=weights, max_intensity=100, point_radius=10.0)
#fig.add_layer(heatmap_layer)
#fig

# Display the map
map

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

df = pd.read_csv('nypd-motor-vehicle-collisions.csv')

df2 = df[['NUMBER OF PERSONS INJURED', 'CONTRIBUTING FACTOR VEHICLE 1']]
df3 = df2.groupby('CONTRIBUTING FACTOR VEHICLE 1').count()
df3

#df2['month'] = df['ACCIDENT DATE'].astype("datetime64").dt.month()
df2.insert(2, "MONTH", df['ACCIDENT DATE'].astype("datetime64").dt.month, True)
df2

df4 = df2[df2['CONTRIBUTING FACTOR VEHICLE 1'] == 'Driver Inexperience']
df4 = df4.groupby('MONTH').count()
df4

plt.plot(df4['CONTRIBUTING FACTOR VEHICLE 1'])
import calendar
# Create a list of month names
month_names = [calendar.month_name[i][0:3] for i in range(1, 13)]
plt.xlabel('Month')
plt.ylabel('Number of Accidents')
plt.title('Number of Accidents Due to Driver Inexperience Throughout The Year')
plt.xticks(range(1,13), month_names)